# 들어가기 전에

- 이 포스팅은 https://reactjs.org/docs/lifting-state-up.html 에 있는 포스팅을 번역한 것입니다. 오역이나 의역이 있을 수 있습니다. 지적해주시면 확인 후 바로 정정하겠습니다.

- original source of this posting is from https://reactjs.org/docs/lifting-state-up.html If the original author requests deletion, it will be deleted immediately.

- Translated by Jake Seo (서진규)

	- https://velog.io/@jakeseo_me
	- https://github.com/n00nietzsche
    
> 리액트 공식문서로 배워보자 #10, 상태 끌어올리기

종종 몇몇 컴포넌트들은 같은 변화하는 데이터를 반영할 필요가 있습니다. 우리는 공유된 상태를 그들의 가장 가까운 공유하는 조상으로 끌어올리는 것을 권장합니다. 실제로는 어떻게 동작하는지 살펴봅시다.

이 섹션에서, 우리는 물이 주어진 온도에서 끓는지 계산하는 온도 계산기를 만들 것입니다.

우리는 먼저 `BoilingVerdict`라는 컴포넌트와 함께 진행해볼 겁니다. 이 컴포넌트는 `celsius` 기온을 prop으로 받습니다. 그리고 그 온도가 물을 끓이기에 충분한지 출력해줍니다.

```js
function BoilingVerdict(props) {
  if (props.celsius >= 100) {
    return <p>The water would boil.</p>;
  }
  return <p>The water would not boil.</p>;
}
```

다음으로 우리는 `Calculator`라고 불리는 컴포넌트를 만들 것입니다. 이 컴포넌트는 기온을 입력할 수 있는 `<input>`을 렌더링하고 그 값을 `this.state.temperature`에 보관합니다.

추가적으로, 이 컴포넌트는 현재 입력 값에 대한 `BoilingVerdict`를 렌더링합니다.

```js
class Calculator extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {temperature: ''};
  }

  handleChange(e) {
    this.setState({temperature: e.target.value});
  }

  render() {
    const temperature = this.state.temperature;
    return (
      <fieldset>
        <legend>Enter temperature in Celsius:</legend>
        <input
          value={temperature}
          onChange={this.handleChange} />

        <BoilingVerdict
          celsius={parseFloat(temperature)} />

      </fieldset>
    );
  }
}
```

**[코드펜에서 해보기](https://codepen.io/gaearon/pen/ZXeOBm?editors=0010)**

# 두번째 입력 값 추가하기

우리의 새로운 요구사항은 섭씨 온도 입력 값에 추가로 화씨 온도 입력을 제공하고 계속 싱크를 유지하는 것입니다.

`Calculator`로부터 `TemperatureInput` 컴포넌트를 추출함으로써 시작할 수 있습니다. 우리는 여기에 새로운 `scale` prop을 추가할 것입니다. `scale`은 `"e"`나 `"f"`가 될 수 있습니다.

```js
const scaleNames = {
  c: 'Celsius',
  f: 'Fahrenheit'
};

class TemperatureInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {temperature: ''};
  }

  handleChange(e) {
    this.setState({temperature: e.target.value});
  }

  render() {
    const temperature = this.state.temperature;
    const scale = this.props.scale;
    return (
      <fieldset>
        <legend>Enter temperature in {scaleNames[scale]}:</legend>
        <input value={temperature}
               onChange={this.handleChange} />
      </fieldset>
    );
  }
}
```

우리는 `Calculator`를 2개의 분리된 온도 입력 창으로 변경할 수 있습니다.

```js
class Calculator extends React.Component {
  render() {
    return (
      <div>
        <TemperatureInput scale="c" />
        <TemperatureInput scale="f" />
      </div>
    );
  }
}
```

**[코드펜에서 직접 해보기](https://codepen.io/gaearon/pen/jGBryx?editors=0010)**

이제 우리는 2개의 입력 창을 가졌습니다. 하지만 둘 중 하나에 온도를 입력할 때, 나머지 것은 업데이트되지 않습니다. 이건 우리의 요구사항에 반대됩니다. 우리는 싱크를 맞추고 싶습니다.

또 우리는 `Calculator`로부터 `BoilingVerdict`를 보여줄 수 없습니다. `Calculator`는 현재의 온도를 알 수 없습니다. 왜냐면 현재의 온도는 `TemperatureInput` 내부에 숨어있기 때문입니다.

# 변환 함수 작성하기

먼저, 우리는 화씨에서 섭씨, 섭씨에서 화씨로 온도를 변경하는 2가지 함수를 작성할 것입니다.

```js
function toCelsius(fahrenheit) {
  return (fahrenheit - 32) * 5 / 9;
}

function toFahrenheit(celsius) {
  return (celsius * 9 / 5) + 32;
}
```

이 두가지 함수는 숫자를 변환합니다. 우리는 문자열 `temperature`를 받고 변환 함수를 인자로 가져와 문자열을 반환하는 다른 함수를 만들 것입니다. 다른 입력 값을 기반으로 입력 값을 계산하는데 이것을 이용할 것입니다.

이 함수는 유효하지 않은 `temperature`에 대해서 빈 문자열을 리턴합니다. 그리고 이 함수는 출력 값을 3번째 소수점에서 반올림합니다.

```js
function tryConvert(temperature, convert) {
  const input = parseFloat(temperature);
  if (Number.isNaN(input)) {
    return '';
  }
  const output = convert(input);
  const rounded = Math.round(output * 1000) / 1000;
  return rounded.toString();
}
```

예를 들면, `tryConvert('abc', toCelsius)`는 빈 문자열을 반환합니다. 그리고 `tryConvert('10.22', toFahrenheit)`은 `50.396`을 반환합니다.

# 상태 끌어올리기

현재, 두 개의 `TemperatureInput` 컴포넌트는 독립적으로 그들의 값을 지역 상태에 저장합니다.

```js
class TemperatureInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {temperature: ''};
  }

  handleChange(e) {
    this.setState({temperature: e.target.value});
  }

  render() {
    const temperature = this.state.temperature;
    // ...  
```

하지만, 우리는 이 두 개의 입력 값이 서로 싱크가 맞길 원합니다. 우리가 섭씨 입력 값을 업데이트 했을 때, 화씨 입력 값은 변환된 값을 반영해야 합니다. 그리고 반대도 같습니다.

리액트에서, 상태를 공유하는 것은 상태를 상태가 필요한 컴포넌트들의 가장 가까운 공통 조상으로 이동시킴으로써 공유할 수 있습니다. 이러한 테크닉은 "상태 끌어올리기(lifting state up)"라고 불립니다. 우리는 지역 상태를 `TemperatureInput`으로부터 제거할 것이고 이 상태를 대신 `Calculator`로 옮길 것입니다.

만일, `Calculator`가 공유된 상태를 소유한다면, `Calculator`는 두 입력값의 현재의 온도에 대한 "source of truth(유일한 원천)"이 됩니다. `Calculator`는 두 입력 값 모두에게 서로 일관성 있는 값을 갖게 할 수 있습니다. 두 `TemperatureInput`의 props가 같은 부모인 `Calculator` 컴포넌트에서 오기 때문에, 두개의 입력 값은 항상 싱크가 맞습니다.

이게 어떻게 작동하는지 단계단계 살펴봅시다.

